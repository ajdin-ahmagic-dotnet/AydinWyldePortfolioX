@using DXApplication3.Models

<div id="section-hero" class="parallax-section">
    <h2>Technical Expertise</h2>
    <div class="portfolio-grid hero-cards">
        <a href="@Url.Action("Skills", "Home", new { id = "Architecture" })" class="portfolio-card random-anim-card">
            <h3>Architecture</h3>
            <p>Cloud-native patterns, Microservices, and Domain-Driven Design.</p>
        </a>
        <a href="@Url.Action("Skills", "Home", new { id = "Backend" })" class="portfolio-card random-anim-card">
            <h3>Backend</h3>
            <p>High-performance APIs, .NET Core, and server-side logic.</p>
        </a>
        <a href="@Url.Action("Skills", "Home", new { id = "Cloud" })" class="portfolio-card random-anim-card">
            <h3>Cloud</h3>
            <p>Azure services, serverless computing, and DevOps automation.</p>
        </a>
         <a href="@Url.Action("Skills", "Home", new { id = "Databases" })" class="portfolio-card random-anim-card">
            <h3>Databases</h3>
            <p>SQL, NoSQL, data modeling, and performance tuning.</p>
        </a>
        <a href="@Url.Action("Skills", "Home", new { id = "Frontend" })" class="portfolio-card random-anim-card">
            <h3>Frontend</h3>
            <p>Modern web frameworks, responsive design, and UX/UI.</p>
        </a>
        <a href="@Url.Action("Skills", "Home", new { id = "Mobile" })" class="portfolio-card random-anim-card">
            <h3>Mobile</h3>
            <p>Cross-platform development with Xamarin and MAUI.</p>
        </a>
         <a href="@Url.Action("Skills", "Home", new { id = "Tools" })" class="portfolio-card random-anim-card">
            <h3>Tools & DevOps</h3>
            <p>CI/CD pipelines, containerization, and developer tooling.</p>
        </a>
        <a href="@Url.Action("Skills", "Home", new { id = "Certifications" })" class="portfolio-card random-anim-card">
            <h3>Certifications</h3>
            <p>Professional recognitions and continuous learning achievements.</p>
        </a>
    </div>
</div>

<div id="section-expertise" class="parallax-section counters-section">
    <h2>Impact & Metrics</h2>
    <div class="counters-grid">
        <div class="counter-item">
            <div class="counter-icon">üíº</div>
            <h3 class="counter-number" data-target="50">0</h3>
            <p class="counter-label">Projects Completed</p>
        </div>
        <div class="counter-item">
            <div class="counter-icon">üöÄ</div>
            <h3 class="counter-number" data-target="25">0</h3>
            <p class="counter-label">Core Technologies</p>
        </div>
        <div class="counter-item">
            <div class="counter-icon">‚≠ê</div>
            <h3 class="counter-number" data-target="98">0</h3>
            <p class="counter-label">Client Satisfaction</p>
        </div>
        <div class="counter-item">
            <div class="counter-icon">üèÜ</div>
            <h3 class="counter-number" data-target="5">0</h3>
            <p class="counter-label">Years Experience</p>
        </div>
    </div>
</div>

<script>
    // Counter animation
    document.addEventListener("DOMContentLoaded", () => {
        const counters = document.querySelectorAll(".counter-number");
        const speed = 200;

        const animateCounters = () => {
            counters.forEach(counter => {
                const target = +counter.getAttribute("data-target");
                const count = +counter.innerText;
                const inc = target / speed;

                if (count < target) {
                    counter.innerText = Math.ceil(count + inc);
                    setTimeout(animateCounters, 1);
                } else {
                    counter.innerText = target;
                }
            });
        };
        
        // Simple intersection observer to start counting when visible
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if(entry.isIntersecting) {
                    animateCounters();
                    observer.unobserve(entry.target);
                }
            });
        }, { threshold: 0.5 });
        
        const grid = document.querySelector(".counters-grid");
        if(grid) observer.observe(grid);
    });
</script>
